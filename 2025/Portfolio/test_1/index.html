<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shader Background with THREE.js</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #shaderCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }
        #content { position: relative; z-index: 1; color: black; padding: 20px; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="content">
        <h1>Interactive Shader Background</h1>
        <p>Hover over the background to see effects.</p>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.144/build/three.min.js"></script>
    <script>
        // Setup the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
        camera.position.z = 1;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const vertexShader = `
            varying vec2 vUv;

            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            precision highp float;

            uniform float time;
            uniform float aspect;
            varying vec2 vUv;

            void main () {
                vec2 center = vUv - 0.5;
                center.x *= aspect;
                float dist = length(center);
                float mask = smoothstep(0.5, 0.2, dist);

                vec3 color = 0.5 + 0.5 * cos(time + vUv.xyx + vec3(0.0, 2.0, 4.0));
                gl_FragColor = vec4(color, mask);
            }
        `;

        const shaderMaterial = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                time: { value: 0 },
                aspect: { value: window.innerWidth / window.innerHeight }
            }
        });

        const planeGeometry = new THREE.PlaneGeometry(2, 2);
        const plane = new THREE.Mesh(planeGeometry, shaderMaterial);
        scene.add(plane);

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            shaderMaterial.uniforms.time.value += 0.05;
            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            shaderMaterial.uniforms.aspect.value = aspect;
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Interactivity: Hover effect or control
        window.addEventListener('mousemove', (event) => {
            // Example: alter time based on horizontal position
            const normalizedX = (event.clientX / window.innerWidth) * 2 - 1;
            shaderMaterial.uniforms.time.value = normalizedX * 10.0;
        });

        animate();
    </script>
</body>
</html>
